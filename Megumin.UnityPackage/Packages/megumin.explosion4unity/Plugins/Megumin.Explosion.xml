<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Megumin.Explosion</name>
    </assembly>
    <members>
        <member name="T:ByteArrayExtension_293399541C8D4E38A03A6340FA15498E">
            <summary>
            字节数据扩展
            </summary>
        </member>
        <member name="M:ByteArrayExtension_293399541C8D4E38A03A6340FA15498E.StartWithBOM(System.Byte[])">
            <summary>
            这个数组是不是以BOM头开始的
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:ByteArrayExtension_293399541C8D4E38A03A6340FA15498E.SkipBOMIfHave(System.Byte[])">
            <summary>
            如果含有BOM头则去掉，不含有返回原数组
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="T:System.Collections.Generic.DictionaryExtension_5191D922C5B740EBB5B4C72E5DA5C11C">
            <summary>
            字典扩展
            </summary>
        </member>
        <member name="M:System.Collections.Generic.DictionaryExtension_5191D922C5B740EBB5B4C72E5DA5C11C.RemoveAll``2(System.Collections.Generic.Dictionary{``0,``1},System.Func{System.Collections.Generic.KeyValuePair{``0,``1},System.Boolean})">
            <summary>
            使用<see cref="T:Megumin.ListPool`1"/>缓存key实现。
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="source"></param>
            <param name="predicate"></param>
        </member>
        <member name="M:System.Collections.Generic.DictionaryExtension_5191D922C5B740EBB5B4C72E5DA5C11C.RemoveAll``1(System.Collections.Generic.Dictionary{System.Int32,``0},System.Func{System.Collections.Generic.KeyValuePair{System.Int32,``0},System.Boolean})">
            <summary>
            如果字典特别大可能会爆栈
            </summary>
            <typeparam name="V"></typeparam>
            <param name="source"></param>
            <param name="predicate"></param>
        </member>
        <member name="M:System.Collections.Generic.DictionaryExtension_5191D922C5B740EBB5B4C72E5DA5C11C.GetForeachRemover``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            获得一个在foreach中使用的删除器
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.IEnumerableExtensionD36DB03F995A41EA836C18482535C530.GetForeachRemover``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            获得一个在foreach中使用的删除器
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.StringExtension_FA3412521A22430AAAF2BB15471A5277.ReplaceFileName(System.String,System.String)">
            <summary>
            安全替换路径中的文件名，会检测是否已经存在。
            </summary>
            <param name="path"></param>
            <param name="newFileName"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.StringExtension_FA3412521A22430AAAF2BB15471A5277.FileNameAddOne(System.String,System.String,System.Int32)">
            <summary>
            如果文件命以数字或者括号数字结尾，则数字加一
            </summary>
            <param name="fileName"></param>
            <param name="namingScheme">数字后缀模式支持SpaceParenthesis Dot Underscore</param>
            <param name="namingDigits">数字长度,不足填充0</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.StringExtension_FA3412521A22430AAAF2BB15471A5277.CreateFileName(System.String,System.String,System.String,System.String,System.Int32)">
            <summary>
            fileName 如果存在，自增
            </summary>
            <param name="dir"></param>
            <param name="fileName"></param>
            <param name="ex">需要前面有 . </param>
            <param name="namingScheme">数字后缀模式支持SpaceParenthesis Dot Underscore</param>
            <param name="namingDigits">数字长度,不足填充0</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:System.Megumin.Class.ExcuteGraph`1" -->
        <member name="M:System.Megumin.Class.SubGraphTemp1.EnterPoint1(System.Threading.CancellationToken)">
            <summary>
            入口没有返回值
            </summary>
            <param name="token"></param>
        </member>
        <member name="P:System.Megumin.Class.SubGraphTemp1.Outpint1">
            <summary>
            出口是可等带的, 等带结果是一个状态码和在图中传递的取消令牌，避免抛出取消异常
            </summary>
        </member>
        <member name="P:System.Megumin.Class.SubGraphTemp1.Outpint2">
            <summary>
            
            </summary>
        </member>
        <member name="P:System.Megumin.Class.PlaySongGraph.Outpint1">
            <summary>
            出口是可等带的, 等带结果是一个状态码和在图中传递的取消令牌，避免抛出取消异常
            </summary>
        </member>
        <member name="M:System.Megumin.Class.PlaySongGraph.PLay(System.Threading.CancellationToken)">
            <summary>
            构建一个流程，播放一首音乐，如果成功播放完成一次，结束时等待N秒自动销毁。
            播放其他音乐会打断当前音乐，如果在此播放正在自动销毁的音乐，停止自动销毁，重置倒计时.
            
            为每个节点分配一个位置编号，位置不同，相同的函数成功失败后执行的逻辑可能不同.
            </summary>
        </member>
        <member name="T:System.Net.IPAddressExtension_A6F086FB3EE3403BB5033720C34DA414">
            <summary>
            IPAddressExtension
            </summary>
        </member>
        <member name="M:System.Net.IPAddressExtension_A6F086FB3EE3403BB5033720C34DA414.GetIntPart(System.Net.IPAddress)">
            <summary>
            取得IP的各个部分
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:System.Net.IPAddressExtension_A6F086FB3EE3403BB5033720C34DA414.GetStringParts(System.Net.IPAddress)">
            <summary>
            取得IP的各个部分
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:System.Net.IPAddressExtension_A6F086FB3EE3403BB5033720C34DA414.IsA(System.Net.IPAddress)">
            <summary>
            是不是A类地址
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:System.Net.IPAddressExtension_A6F086FB3EE3403BB5033720C34DA414.IsB(System.Net.IPAddress)">
            <summary>
            是不是B类地址
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:System.Net.IPAddressExtension_A6F086FB3EE3403BB5033720C34DA414.IsC(System.Net.IPAddress)">
            <summary>
            是不是C类地址
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:System.Net.IPAddressExtension_A6F086FB3EE3403BB5033720C34DA414.IsD(System.Net.IPAddress)">
            <summary>
            是不是D类地址（多点广播）
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:System.Net.IPAddressExtension_A6F086FB3EE3403BB5033720C34DA414.IsE(System.Net.IPAddress)">
            <summary>
            是不是E类地址（广播）
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:System.Net.IPAddressExtension_A6F086FB3EE3403BB5033720C34DA414.IsLAN(System.Net.IPAddress)">
            <summary>
            判断地址是不是局域网地址
            <para/> LAN，全称Local Area Network，中文名叫做局域网。
            <para/> WAN，全称Wide Area Network，中文名叫做广域网。
            <para/> WLAN，全称Wireless LAN, 无线局域网。
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:System.Net.IPAddressExtension_A6F086FB3EE3403BB5033720C34DA414.IsLocalAddress(System.Net.IPAddress)">
            <summary>
            判断地址是不是局域网地址
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:System.Net.IPAddressExtension_A6F086FB3EE3403BB5033720C34DA414.IsPingIP(System.Net.IPAddress,System.Int32)">
            <summary>
            尝试Ping指定IP是否能够Ping通
            </summary>
            <param name="address">指定IP</param>
            <param name="timeout">Ping类默认超时是5000 https://source.dot.net/#System.Net.Ping/System/Net/NetworkInformation/Ping.cs,16</param>
            <returns>true 是 false 否</returns>
        </member>
        <member name="M:System.Net.IPAddressExtension_A6F086FB3EE3403BB5033720C34DA414.GetLANIP(System.Net.Sockets.AddressFamily)">
            <summary>
            取得局域网IP
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Net.IPAddressExtension_A6F086FB3EE3403BB5033720C34DA414.GetGateway(System.Net.Sockets.AddressFamily,System.Boolean)">
            <summary>
            取得网关IP
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Net.IPAddressExtension_A6F086FB3EE3403BB5033720C34DA414.GetWANIP(System.Net.Sockets.AddressFamily)">
            <summary>
            取得广域网IP
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Net.IPAddressExtension_A6F086FB3EE3403BB5033720C34DA414.GetIP(System.Boolean,System.Net.Sockets.AddressFamily)">
            <summary>
            取得IP
            <para>true取得局域网IP，flase取得外网IP，默认值为flase</para>
            </summary>
            <param name="IsLAN">true取得局域网IP，flase取得外网IP，默认值为flase</param>
            <param name="addressFamily"></param>
            <returns></returns>
        </member>
        <member name="M:System.ObjectExtension.SimilarityCopyTo(System.Object,System.Object,System.Boolean,System.Reflection.BindingFlags)">
            <summary>
            反射复制字段属性的值,近似匹配
            </summary>
            <param name="source"></param>
            <param name="target"></param>
            <param name="useNameFindMode"></param>
            <param name="flags"></param>
        </member>
        <member name="M:System.Reflection.FieldInfoExtension_E5A239CE4DB34975A4A939379BA9A036.CollectSupportType(System.Reflection.FieldInfo,System.Collections.Generic.HashSet{System.Type},System.Func{System.Reflection.Assembly,System.Boolean},System.Boolean,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            反射查找<see cref="T:Megumin.SupportTypesAttribute"/>设定中支持的类型。
            </summary>
            <param name="fieldInfo"></param>
            <param name="allTypes">结果集</param>
            <param name="assemblyFilter">程序集过滤回调</param>
            <param name="collectSelfTypeIfNoAttribute">没有SupportTypesAttribute时，使用自身类型作为支持类型</param>
            <param name="useGenericArgumentsTypeInsteadCollectionType">遇到泛型集合时，使用泛型参数类型代替集合类型</param>
            <param name="extraCheck">额外搜索的程序集</param>
        </member>
        <member name="T:EnumExtension_5108BEA26E8C44D9A538646E15B6B175">
            <summary>
            对枚举类的扩展
            </summary>
        </member>
        <member name="M:EnumExtension_5108BEA26E8C44D9A538646E15B6B175.CheckFlags``1">
            <summary>
            检查是否有FlagsAttribute
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Megumin.AliasAttribute">
            原则，能不定义的特性，就不要定义。能不定义的枚举，就不要定义。
            能不定义的接口，就不要定义。接口可能都是特例，而且需要最小原则，大多时找不到能代替的。
            使用反射先做个所有特性列表 枚举列表，生一个代码方便F1, F12，所有特性都new一个，看名字那个顺眼用哪个。
            冲突与语义，尽量选功能交叉比较小的特性去使用。避免功能冲突。
            尽量选择AttributeTargets.All  AllowMultiple = true, Inherited = true 一致的。
            很多特性用于传参，其实可以用字符串传参。这样原生特性选择性就大大提高。
            例如：
            <see cref="T:System.ComponentModel.CategoryAttribute"/>
            <see cref="T:System.ComponentModel.DescriptionAttribute"/>
            <see cref="T:System.ComponentModel.AttributeProviderAttribute"/>
            <see cref="T:System.ComponentModel.LookupBindingPropertiesAttribute"/>
            尽量删除自己的特性，改用原生特性。
            为了兼容第三方插件，尽量不要声明自己的特性，使用.net 原生特性（或者unity特性，尽可能不用）。
            unity 项目中或者unity插件就无法避免要从 PropertyAttribute，不过能用unity原生特性就尽量原生。
            第三方插件与行为树做兼容时就不必引用你的包。
            这样很多特性就不必定义了。少即是多。
            既然设计理念是一个特性可以用于不同的功能，那么为了方式冲突，特性中应该增几个一个识别字段 Feature,平时不用保持为空。
            冲突时可以增加一个标记用于检测。检测 Feature == null || Feature.Contain “FeatureName” 才确认执行特性。
            同理。通用枚举也尽量不要用，改用string或者int，跨模块传参时更方便，避免不必要耦合。
            接口则不在这个范围，定义接口通常都是十分确切的功能。除非功能和.net底层接口重合。
            C# 泛型没有成员约束，不然就不用定义接口了。
            <summary>
            别名
            </summary>
        </member>
        <member name="P:Megumin.AliasAttribute.Feature">
            <summary>
            <para>设计理念是一个特性可以用于不同的功能，冲突时这个标记用于检测。</para>
            检测 <![CDATA[string.IsNullOrEmpty(Feature) || Feature.Contains("FeatureName")]]> 才确认执行特性。
            </summary>
        </member>
        <member name="P:Megumin.AliasAttribute.Alias">
            <summary>
            别名
            </summary>
        </member>
        <member name="P:Megumin.ShortNameAttribute.Feature">
            <summary>
            <para>设计理念是一个特性可以用于不同的功能，冲突时这个标记用于检测。</para>
            检测 <![CDATA[string.IsNullOrEmpty(Feature) || Feature.Contains("FeatureName")]]> 才确认执行特性。
            </summary>
        </member>
        <member name="P:Megumin.ShortNameAttribute.Name">
            <summary>
            别名
            </summary>
        </member>
        <member name="P:Megumin.SupportTypesAttribute.Feature">
            <summary>
            <para>设计理念是一个特性可以用于不同的功能，冲突时这个标记用于检测。</para>
            检测 <![CDATA[string.IsNullOrEmpty(Feature) || Feature.Contains("FeatureName")]]> 才确认执行特性。
            </summary>
        </member>
        <member name="P:Megumin.SupportTypesAttribute.IncludeChildInOtherAssembly">
            <summary>
            是否包含其他程序集的子类型,默认false,支持，谨慎使用，可能会导致编辑器卡顿.
            </summary>
        </member>
        <member name="P:Megumin.SupportTypesAttribute.IncludeChildInSameAssembly">
            <summary>
            是否包含同一程序集的子类型,默认true
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Megumin.SupportTypesAttribute.AllowAbstract">
            <summary>
            是否允许抽象类型,默认false
            </summary>
        </member>
        <member name="P:Megumin.SupportTypesAttribute.AllowInterface">
            <summary>
            是否允许接口类型,默认false
            </summary>
        </member>
        <member name="P:Megumin.SupportTypesAttribute.AllowGenericType">
            <summary>
            是否允许泛型类型,默认true
            </summary>
        </member>
        <member name="T:Megumin.GenarateNameAttribute">
            <summary>
            生成名字时的生成方式.
            </summary>
        </member>
        <member name="P:Megumin.GenarateNameAttribute.Feature">
            <summary>
            <para>设计理念是一个特性可以用于不同的功能，冲突时这个标记用于检测。</para>
            检测 <![CDATA[string.IsNullOrEmpty(Feature) || Feature.Contains("FeatureName")]]> 才确认执行特性。
            </summary>
        </member>
        <member name="P:Megumin.GenarateNameAttribute.PrefixType">
            <summary>
            None,
            Fixed,
            Dynamic
            </summary>
        </member>
        <member name="T:Megumin.OnF1Attribute">
            <summary>
            在unity中,仅编辑器有效,回调标记的方法
            </summary>
        </member>
        <member name="P:Megumin.OnF1Attribute.Feature">
            <summary>
            <para>设计理念是一个特性可以用于不同的功能，冲突时这个标记用于检测。</para>
            检测 <![CDATA[string.IsNullOrEmpty(Feature) || Feature.Contains("FeatureName")]]> 才确认执行特性。
            </summary>
        </member>
        <member name="T:Megumin.OnKeyAttribute">
            <summary>
            <para>todo, 现在仅部分按键有效 </para>
            在unity中,仅编辑器有效,回调标记的方法
            </summary>
        </member>
        <member name="P:Megumin.OnKeyAttribute.Feature">
            <summary>
            <para>设计理念是一个特性可以用于不同的功能，冲突时这个标记用于检测。</para>
            检测 <![CDATA[string.IsNullOrEmpty(Feature) || Feature.Contains("FeatureName")]]> 才确认执行特性。
            </summary>
        </member>
        <member name="T:Megumin.CDTimer`1">
            <inheritdoc cref="T:Megumin.IUseable`1"/>
        </member>
        <member name="T:Megumin.CoolDownTime">
            <summary>
            
            </summary>
        </member>
        <member name="P:Megumin.CoolDownTime.CoolDown">
            <summary>
            是否冷却完毕
            </summary>
        </member>
        <member name="M:Megumin.CoolDownTime.op_Implicit(Megumin.CoolDownTime)~System.Boolean">
            <summary>
            是否冷却完毕
            </summary>
            <param name="time"></param>
        </member>
        <member name="P:Megumin.CoolDownTime.Last">
            <summary>
            上次返回冷却完毕的时间
            </summary>
        </member>
        <member name="P:Megumin.CoolDownTime.MinDelta">
            <summary>
            最小间隔
            </summary>
        </member>
        <member name="T:Megumin.DisposeHandler">
            <summary>
            观察者模式注册时需要返回IDisposable，这里时将一个回调包装成一个IDisposable
            <seealso cref="M:System.IObservable`1.Subscribe(System.IObserver{`0})"/>
            </summary>
            <remarks>
            https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/types/anonymous-types
            <para/>
            C# 不允许匿名类实现接口，所以必须声明一个类型。
            </remarks>
        </member>
        <member name="F:Megumin.EventValue`1.value">
            <summary>
            这里public是为了能在unity中序列化，这里没办法标记SerializeField
            </summary>
        </member>
        <member name="T:Megumin.EventValue`1.ValueObservable">
            <summary>
            为什么需要这个类型包装一次，IObserver.OnNext 不能与ValueChange时间匹配。
            </summary>
        </member>
        <member name="T:Megumin.InterlockedID`1">
            <summary>
            线程安全ID生成器
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Megumin.iint">
            <summary>
            int 最大值最小值表示无穷
            <para/>https://stackoverflow.com/questions/21312081/how-to-represent-integer-infinity
            </summary>
        </member>
        <member name="P:Megumin.iint.IsPositiveInfinity">
            <summary>
            是不是正无穷
            </summary>
        </member>
        <member name="P:Megumin.iint.IsNegativeInfinity">
            <summary>
            是不是负无穷
            </summary>
        </member>
        <member name="F:Megumin.iint.PositiveInfinity">
            <summary>
            正无穷
            </summary>
        </member>
        <member name="F:Megumin.iint.NegativeInfinity">
            <summary>
            负无穷
            </summary>
        </member>
        <member name="T:Megumin.K2Dictionary`3">
            <summary>
            不是线程安全的
            </summary>
            <typeparam name="TKey1"></typeparam>
            <typeparam name="TKey2"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:Megumin.MeguminUtility">
            <summary>
            常用工具
            </summary>
        </member>
        <member name="M:Megumin.MeguminUtility.Detail``1(``0)">
            <summary>
            反射出类的值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Megumin.Multiple`2">
            <summary>
            <inheritdoc cref="T:Megumin.IMultiple`2"/>
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="M:Megumin.Multiple`2.ApplyValue(System.Boolean)">
            <summary>
            应用值,使用<see cref="T:System.Collections.Generic.EqualityComparer`1"/>比较是否发生改变,优化了装箱.
            </summary>
        </member>
        <member name="M:Megumin.Multiple`2.Refresh(System.Boolean)">
            <summary>
            在控制项没有变动的情况下，触发ApplyValue，尝试触发事件。
            </summary>
        </member>
        <member name="M:Megumin.Multiple`2.EqualsKey(`0,`0)">
            <summary>
            判定Key是否相等
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
            <remarks>
            必须使用EqualsKey，EqualsValue两个函数名，不能同名使用重载，否则在子类重写时会提示二义性，无法重写，编译错误。
            </remarks>
        </member>
        <member name="M:Megumin.Multiple`2.CalNewValue">
            <summary>
            计算新的值, 返回值也可以用KeyValuePair,没什么区别.
            </summary>
            <returns></returns>
            <remarks>有的多重控制并不是比较大小,例如FlagEnum,可能时其他运算</remarks>
        </member>
        <member name="M:Megumin.Multiple`2.OnValueChangedKV(System.ValueTuple{`0,`1},System.ValueTuple{`0,`1})">
            <summary>
            包装一下,不然子类不能调用. Event不带On,方法带On.
            </summary>
            <param name="newValue"></param>
            <param name="oldValue"></param>
        </member>
        <member name="M:Megumin.Multiple`2.op_Implicit(Megumin.Multiple{`0,`1})~`1">
            <summary>
            返回当前值
            </summary>
        </member>
        <member name="T:Megumin.Multiple`2.PropertyObserver">
            <summary>
            为什么需要这个类型包装一次，IObserver.OnNext 不能与ValueChange时间匹配。
            </summary>
        </member>
        <member name="M:Megumin.Multiple`2.Subscribe(System.IObserver{System.ValueTuple{`0,`1}})">
            <summary>
            当前键值任一发生改变时触发
            </summary>
            <param name="observer"></param>
            <returns></returns>
        </member>
        <member name="T:Megumin.IMultipleControlable`2">
            <summary>
            多重值控制器。
            [不提供默认值访问，也不保存默认值。会导致过渡设计。] 后来证明需要访问,加上了!!!
            </summary>
            <remarks>
            用例：当前声音100，
            A功能需要将声音压低为20，A功能结束后恢复原音量。
            B功能需要将声音改为50，B功能结束后恢复音量。
            <para></para>
            常规做法：A设置20前取得当前音量，结束后设置回去。
            这种做法可能导致B功能开始时取得的当前值是A已经设置的音量20。
            最终结束时B将音量设置为20，导致音量出错。
            <para></para>
            实现思路：
            控制器由值持有者初始化，并将自身和默认设定到控制器中。
            想要控制声音，将一个对象当作key传递给控制器，
            控制器从所有想要控制值的列表中选出想要的值。
            <para></para>
            用例2：多个功能想要黑屏Loading。只要有一个功能还需要Loading，那么Loading就不该消失。
            <para></para>
            用例3: 多个地方各自不同禁用某些物品使用,类型是FlagEnum,每处禁用的物品类型有重叠,
            这时用一个枚举值来存共有哪些禁用,就无法实现需求.
            </remarks>
        </member>
        <member name="M:Megumin.IMultipleControlable`2.Control(`0,`1,System.Boolean)">
            <summary>
            开始控制
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="forceRaiseEvent"></param>
        </member>
        <member name="M:Megumin.IMultipleControlable`2.Cancel(`0,`1,System.Boolean)">
            <summary>
            取消控制
            </summary>
            <param name="key"></param>
            <param name="value">因为总是复制粘贴Control,参数个数对不上,这个值没有使用,只是为了对其参数个数.</param>
            <param name="forceRaiseEvent"></param>
        </member>
        <member name="M:Megumin.IMultipleControlable`2.CancelAll(System.Boolean)">
            <summary>
            取消除默认值以外的所有控制
            </summary>
        </member>
        <member name="T:Megumin.MultipleControlBase`3">
            <inheritdoc cref="T:Megumin.IMultipleControlable`2"/>
            <summary>
            多重值控制器。
            [不提供默认值访问，也不保存默认值。会导致过渡设计。] 后来证明需要访问,加上了!!!
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <typeparam name="C">构造中使用参数类型,初始化排序缓存时使用的参数</typeparam>
        </member>
        <member name="P:Megumin.MultipleControlBase`3.Controllers">
            <summary>
            TODO,使用最大堆最小堆优化
            </summary>
        </member>
        <member name="M:Megumin.MultipleControlBase`3.#ctor(`0,`1,Megumin.OnValueChanged{System.ValueTuple{`0,`1}},Megumin.OnValueChanged{`1},`2)">
            <summary>
            
            </summary>
            <param name="defaultKey"></param>
            <param name="defaultValue"></param>
            <param name="onValueChangedKV"></param>
            <param name="onValueChanged"></param>
            <param name="init"></param>
        </member>
        <member name="M:Megumin.MultipleControlBase`3.InitInCtor(`2)">
            <summary>
            构造函数中间调用的虚方法,用于初始化排序字段,在第一次<see cref="M:Megumin.Multiple`2.ApplyValue(System.Boolean)"/>前调用.
            <para>不需要排序的或者计算方式不需要缓存的,可以忽略这个函数.</para>
            这个主要作用用来初始化排序的linq表达式.
            </summary>
        </member>
        <member name="M:Megumin.MultipleControlBase`3.op_Implicit(Megumin.MultipleControlBase{`0,`1,`2})~`1">
            <summary>
            返回当前值
            </summary>
            <param name="multipleControl"></param>
        </member>
        <member name="T:Megumin.MultipleControl`2">
            <inheritdoc/>
        </member>
        <member name="F:Megumin.MultipleControl`2.SortLinqKV">
            <summary>
            排序用Linq表达式
            </summary>
        </member>
        <member name="M:Megumin.MultipleControl`2.#ctor(`0,`1,Megumin.OnValueChanged{System.ValueTuple{`0,`1}},Megumin.OnValueChanged{`1},System.Boolean)">
            <summary>
            构造函数
            </summary>
            <param name="defaultKey"></param>
            <param name="defaultValue"></param>
            <param name="onValueChangedKV"></param>
            <param name="onValueChanged"></param>
            <param name="ascending">true 按升序排列，结果为应用最小值，false为降序排列，结果为应用最大值。</param>
        </member>
        <member name="M:Megumin.MultipleControl`2.InitSortLinq(System.Boolean)">
            <summary>
            初始化值计算
            </summary>
            <remarks>默认根据值升序,应用第一个值，也就是结果最小的</remarks>
        </member>
        <member name="M:Megumin.MultipleControl`2.ReInitSortLinq(System.Boolean)">
            <summary>
            true 按升序排列，结果为应用最小值，false为降序排列，结果为应用最大值。
            </summary>
            <param name="ascending"></param>
        </member>
        <member name="M:Megumin.MultipleControl`2.CalNewValue">
            <summary>
            计算新的值, 返回值也可以用KeyValuePair,没什么区别.
            </summary>
            <returns></returns>
            <remarks>有的多重控制并不是比较大小,例如FlagEnum,可能时其他运算</remarks>
        </member>
        <member name="T:Megumin.ActiveControl">
            <summary>
            开启关闭控制，默认只要有个一个控制源为true，结果就是true.
            <para>可以将ascending参数设置为true,改为 只要有个一个源为false,结果就是false.</para>
            </summary>
            <remarks>处理黑屏，碰撞盒开闭</remarks>
        </member>
        <member name="M:Megumin.ActiveControl.#ctor(System.Object,System.Boolean,Megumin.OnValueChanged{System.ValueTuple{System.Object,System.Boolean}},Megumin.OnValueChanged{System.Boolean},System.Boolean)">
            <summary>
            
            </summary>
            <param name="defaultHandle"></param>
            <param name="defaultValue"></param>
            <param name="onValueChangedKV"></param>
            <param name="onValueChanged"></param>
            <param name="ascending">默认false,降序排列,true=1排在false=0前面,结果为第一个值.任意一个true结果就true</param>
        </member>
        <member name="T:Megumin.AnyTrueControl">
            <summary>
            开启控制，只要有个一个控制源为true，结果就是true.
            </summary>
            <remarks>
            例如处理黑屏过渡
            </remarks>
        </member>
        <member name="T:Megumin.AnyFalseControl">
            <summary>
            关闭控制，只要有一个控制源为false,结果就是false.
            </summary>
        </member>
        <member name="T:Megumin.MultipleSelector`2">
            <summary>
            从一组对象中选择一个对象
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="T:Megumin.PrioritySelector`1">
            <summary>
            开关权重对象选择器
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Megumin.MultipleValue`2">
            <summary>
            复合值，一个值的某些构成是有限时间的。
            和IMultipleControlable很像，但是不排序，是求和。
            <para></para>
            需求一：最初需求是被弹反给自己增加一个被弹反计数，这一个有效期5秒，如果计数大于3，进入被弹反硬直。
            这导致弹反计数中，每个弹反点有自己的生命周期，计算总和十分麻烦。
            <para></para>
            需求二：护盾由各种护盾构成，蓝盾黄甲，算是生命值，每个构成项可以被消耗。
            如果HP500，蓝盾200，黄甲300，遇到 350点伤害，消耗掉蓝盾100，黄甲100，HP150。
            <para></para>
            需求三：仇恨与威胁值系统，WOW中一个节能产生的仇恨是有时间的，过了时间会消退，和需求一同理。
            如果通过buff实现，buff数量暴增。
            计时器是可以实现的，但是容易出bug，对象已经被销毁等。中途整个威胁值已经被重置等，先加后减问题非常多。
            当前思路是给每个构成项一个key，减去移除的时候识别这个key是不是有效。如果已经移除过或整体重置，不会重复减去。
            </summary>
        </member>
        <member name="T:Megumin.IntMultipleValue`1">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="T:Megumin.MultipleValueEnum`2">
            <summary>
            用于FlagEnum,最好用枚举类型实现一次.
            性能有些额外损失,至少每次计算都要Tostring,甚至装箱一次,不确定.<see cref="M:Megumin.MultipleValueEnum`2.CalNewValue"/>.
            </summary>
            <inheritdoc/>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="M:Megumin.MultipleValueEnum`2.CalNewValue">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Megumin.MultipleValueEnumKeypadSudoku">
            <summary>
            枚举示例<see cref="M:Megumin.MultipleValueEnumKeypadSudoku.CalNewValue"/>. FlagEnum排序没有意义,使用|运算.
            </summary>
        </member>
        <member name="T:Megumin.MultipleValueCollection`2">
            <summary>
            并集.
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="M:Megumin.MultipleValueCollection`2.CalNewValue">
            <summary>
            去并集
            </summary>
            <returns></returns>
        </member>
        <member name="T:Megumin.NotInitException">
            <summary>
            未初始化异常
            </summary>
        </member>
        <member name="T:Megumin.OneoffEvent`1">
            <summary>
            使用异步代替一次性回调，免手动清理注册。
            <para/>触发一次，清除所有注册。
            <para/>弊端，如果不触发，永久保存引用，无法主动清除，容易内存泄漏。
            <para/>适用于短生命周期对象。
            <para/>谨慎使用。
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Megumin.OneoffEvent`1.UnRegistAll">
            <summary>
            会清除所有注册的事件，不能清除指定事件。
            </summary>
        </member>
        <member name="T:Megumin.OneoffEventWeak`1">
            <summary>
            弱引用一次性事件. TODO,弱引用没起作用
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Megumin.OneoffEvent2`1">
            <summary>
            支持主动取消的一次性异步事件
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Megumin.IPoolCore`1">
            <summary>
            对象池核心容器 
            参考了UnityEngine.Rendering.ObjectPool,并做了优化.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Megumin.IPoolCore`1.Rent">
            <summary>
            从池中租用一个元素
            </summary>
            <returns></returns>
        </member>
        <member name="M:Megumin.IPoolCore`1.Return(`0@,System.Boolean)">
            <summary>
            将一个元素返回池,调用者需要保证归还后不在使用当前list
            <para/>虽然调用后list被赋值为null，但不能保证没有其他引用指向当前list，尤其小心被保存在Linq语句中的引用。
            </summary>
            <param name="element">使用ref 来保证list被置为null,防止出现数据错误.</param>
            <param name="forceSafeCheck">安全检查,检测最大保留个数,数据结构检测重复元素,有性能开销</param>
        </member>
        <member name="T:Megumin.IPoolCore`1.ReturnHandle">
            <summary>
            自动归还句柄,推荐使用using语法
            </summary>
        </member>
        <member name="M:Megumin.IPoolCore`1.ReturnHandle.Dispose">
            <summary>
            Disposable pattern implementation.
            </summary>
        </member>
        <member name="M:Megumin.IPoolCore`1.Rent(`0@,System.Boolean)">
            <summary>
            使用using自动归还
            </summary>
            <returns></returns>
            <param name="element"></param>
            <param name="forceSafeCheck"></param>
        </member>
        <member name="F:Megumin.PoolCoreBase`1.PostRentPop">
            <summary>
            在Pop后一刻调用,如果返回false,则构造新元素.
            </summary>
        </member>
        <member name="F:Megumin.PoolCoreBase`1.PreReturnPush">
            <summary>
            在Push前一刻调用,如果返回false,则不Push.
            </summary>
        </member>
        <member name="P:Megumin.PoolCoreBase`1.MaxSize">
            <summary>
            池中最大保留元素个数,默认为10
            </summary>
        </member>
        <member name="F:Megumin.Pool`1.poolCore">
            <summary>
            不要继承静态自动,父类和子类共有可能存在隐藏bug
            </summary>
        </member>
        <member name="M:Megumin.Pool`1.Rent">
            <summary>
            <inheritdoc cref="M:Megumin.IPoolCore`1.Rent"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Megumin.Pool`1.Rent(`0@,System.Boolean)">
            <summary>
            <inheritdoc cref="M:Megumin.IPoolCore`1.Rent(`0@,System.Boolean)"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Megumin.Pool`1.Return(`0@,System.Boolean)">
            <summary>
            <inheritdoc cref="M:Megumin.IPoolCore`1.Return(`0@,System.Boolean)"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Megumin.ListPool`1">
            <summary>
            线程不安全List池
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>内部使用<see cref="T:System.Collections.Generic.Stack`1"/>实现</remarks>
        </member>
        <member name="T:Megumin.ConcurrentListPool`1">
            <summary>
            线程安全List池
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>内部使用<see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>实现</remarks>
        </member>
        <member name="T:Megumin.HashSetPool`1">
            <summary>
            线程不安全HashSet池
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>内部使用<see cref="T:System.Collections.Generic.Stack`1"/>实现</remarks>
        </member>
        <member name="T:Megumin.ConcurrentHashSetPool`1">
            <summary>
            线程安全HashSet池
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>内部使用<see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>实现</remarks>
        </member>
        <member name="M:Megumin.Node`1.Pop">
            <summary>
            从原位置摘出来并修复前后链接
            </summary>
        </member>
        <member name="M:Megumin.Node`1.AfterInsert(Megumin.Node{`0})">
            <summary>
            在 this 后面插入 node
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Megumin.Node`1.BeforeInsert(Megumin.Node{`0})">
            <summary>
            在 this 前面插入 node
            </summary>
            <param name="node"></param>
        </member>
        <member name="T:Megumin.Ring`1">
            <summary>
            双向环,用来做前进后退堆栈。
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Megumin.Ring`1.Expand(Megumin.Node{`0},System.Int32,`0)">
            <summary>
            扩容
            </summary>
        </member>
        <member name="T:Megumin.SimpleMatcher">
            <summary>
            简单的匹配器
            </summary>
        </member>
        <member name="T:Megumin.SimplePipeQueue`1">
            <summary>
            异步缓存管道
            <para/>也可以通过（bool isEnd,T value）元组，来实现终止信号
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Megumin.SimplePipeQueueWithEndSignal`1">
            <summary>
            <inheritdoc/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Megumin.QueuePipe`1">
            <summary>
            <inheritdoc cref="T:Megumin.IPipe`1"/>
            <para></para>这是个简单的实现,更复杂使用微软官方实现<see cref="!:System.Threading.Channels.Channel.CreateBounded&lt;T&gt;(int)"/>
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>
            <para/> 如果能用 while(true),就不要用递归。
            <para/> 在捕捉上下文时，while(true)堆栈更少更清晰，逻辑上复合直觉，不容易爆栈。
            <para/> 递归还会导致方法引用计数增加，阅读代码时制造混乱。
            </remarks>
        </member>
        <member name="T:Megumin.QueueSignalPipe`1">
            <summary>
            <inheritdoc/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Megumin.StackPipe`1">
            <summary>
            <inheritdoc cref="T:Megumin.IPipe`1"/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Megumin.DefaultThreadSwitcher">
            <summary>
            <inheritdoc cref="T:Megumin.ThreadSwitcher"/>
            </summary>
        </member>
        <member name="M:Megumin.DefaultThreadSwitcher.Tick">
            <summary>
            <inheritdoc cref="M:Megumin.ThreadSwitcher.Tick"/>
            </summary>
        </member>
        <member name="M:Megumin.DefaultThreadSwitcher.Switch(System.Action)">
            <summary>
            <inheritdoc cref="M:Megumin.ThreadSwitcher.Switch(System.Action)"/>
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Megumin.DefaultThreadSwitcher.Switch2">
            <summary>
            <inheritdoc cref="M:Megumin.ThreadSwitcher.Switch2"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Megumin.DefaultThreadSwitcher.Switch1(System.Int32)">
            <inheritdoc cref="M:Megumin.ThreadSwitcher.Switch1(System.Int32)"/>
        </member>
        <member name="M:Megumin.DefaultThreadSwitcher.Switch3MaxWait(System.Int32)">
            <summary>
            <inheritdoc cref="M:Megumin.ThreadSwitcher.Switch3MaxWait(System.Int32)"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Megumin.ThreadSwitcher">
            <summary>
            通用线程切换器
            <para/>异步后续在<see cref="M:Megumin.ThreadSwitcher.Tick"/>线程调用。
            <para/>通用性高,但是用到TaskCompletionSource和异步各种中间对象和异步机制.
            <para/>性能开销大,不如明确的类型和回调接口<see cref="M:Megumin.ThreadSwitcher.Switch(System.Action)"/>.
            </summary>
        </member>
        <member name="M:Megumin.ThreadSwitcher.Tick">
            <summary>
            由指定线程调用,回调其他线程需要切换到这个线程的方法
            </summary>
        </member>
        <member name="M:Megumin.ThreadSwitcher.Switch(System.Action)">
            <summary>
            切换执行线程
            <seealso cref="M:Megumin.ThreadSwitcher.Switch2"/>
            </summary>
            <param name="action"></param>
            <remarks>线程切换过程中闭包几乎无法避免, 除非明确回调函数参数类型.
            <para>对于性能敏感区域,可以写特定代码消除闭包. 参考 megumin.net</para>
            </remarks>
        </member>
        <member name="T:Megumin.ThreadSwitcher.SwitcherSource2">
            <summary>
            切换线程专用Soucre，不建议保留引用，请直接await。
            </summary>
        </member>
        <member name="M:Megumin.ThreadSwitcher.Switch2">
            <summary>
            使用特殊异步source切换线程。
            <para/>source只有await 执行后，才会入队<see cref="F:Megumin.ThreadSwitcher.WaitQueue2"/>
            </summary>
            <remarks></remarks>
            <returns></returns>
        </member>
        <member name="F:Megumin.ThreadSwitcher.WaitQueue1">
            <summary>
            可以合并Source来提高性能,但是会遇到异步后续出现异常的情况,比较麻烦.
            所以每个Switch调用处使用不同的source,安全性更好
            </summary>
        </member>
        <member name="M:Megumin.ThreadSwitcher.Switch1(System.Int32)">
            <summary>
            <para>保证返回值先await 后Tick, 不然 await会发现Task同步完成,无法切换线程.</para>
            <para><see cref="P:System.Threading.Tasks.Task.Status"/>无法指示是否被await </para>
            </summary>
            <returns></returns>
            <remarks>BUG,无法保证先await 后Tick</remarks>
        </member>
        <member name="T:Megumin.ThreadSwitcher.SwitcherSource3">
            <summary>
            切换线程专用Soucre，不要保留引用，请直接await。
            </summary>
        </member>
        <member name="P:Megumin.ThreadSwitcher.SwitcherSource3.IsAwaiting">
            <summary>
            表示调用线程已经进入异步await
            </summary>
        </member>
        <member name="P:Megumin.ThreadSwitcher.SwitcherSource3.MaxWaitMilliseconds">
            <summary>
            最大等待轮询时间，超出这个时间将不在同步完成。失去切换线程的作用。
            </summary>
        </member>
        <member name="M:Megumin.ThreadSwitcher.Switch3MaxWait(System.Int32)">
            <summary>
            使用特殊异步source切换线程，请直接await。
            如果没有await，经过<paramref name="maxWaitMilliseconds"/>后将会被完成，失去切换线程的作用，
            但不会阻塞线程切换器。
            <para/>source会立即入队<see cref="F:Megumin.ThreadSwitcher.WaitQueue3"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Megumin.Threshold`1">
            <summary>
            阈
            </summary>
        </member>
        <member name="P:Megumin.Threshold`1.Lower">
            <summary>
            下界
            </summary>
        </member>
        <member name="P:Megumin.Threshold`1.Upper">
            <summary>
            上界
            </summary>
        </member>
        <member name="M:Megumin.Threshold`1.#ctor(`0,`0)">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:Megumin.Threshold`1.Contain(`0)">
            <summary>
            是不是在界限内
            </summary>
        </member>
        <member name="M:Megumin.Threshold`1.op_LessThan(`0@,Megumin.Threshold{`0}@)">
            <summary>
            是否小于下界
            </summary>
        </member>
        <member name="M:Megumin.Threshold`1.op_GreaterThan(`0@,Megumin.Threshold{`0}@)">
            <summary>
            是否大于上界
            </summary>
        </member>
        <member name="T:Megumin.Utility">
            <summary>
            工具
            </summary>
            <remarks>MeguminUtility名字太长,即时Utility和别的命名空间Utility冲突,使用全名称限定就可以了.</remarks>
        </member>
        <member name="T:Megumin.Utility.IToStringReflectionMemberValueToStringCallbackHandle">
            <summary>
            字段值T哦string时回调。用于一些无法重写ToString的类。
            </summary>
        </member>
        <member name="P:Megumin.Utility.MemberValueToStringCallbackHandle">
            <summary>
            唯一回调，ToStringReflection参数太多了直接静态属性好了。
            </summary>
        </member>
        <member name="M:Megumin.Utility.ToStringReflection``1(``0,System.Boolean)">
            <summary>
            通过反射获得属性值字符串
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="actualType">默认true通过value取得实际类型,false取得泛型类型,T可能是接口类型</param>
            <returns></returns>
        </member>
        <member name="M:Megumin.Utility.ToStringReflection``1(System.Type,``0,System.Nullable{System.Reflection.BindingFlags})">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
            <param name="value"></param>
            <param name="flags">允许设定<see cref="F:System.Reflection.BindingFlags.NonPublic"/></param>
            <returns></returns>
        </member>
        <member name="M:Megumin.Utility.TryGetName``1(``0,System.String@)">
            <summary>
            反射拿名字
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Megumin.Utility.LogListDic(System.String,System.Object)">
            <summary>
            打印详细集合
            </summary>
            <param name="retract"></param>
            <param name="fo"></param>
            <returns></returns>
        </member>
        <member name="T:Megumin.Utility2">
            <summary>
            因为由扩展方法和静态方法重名, this扩展不能有默认值,
            </summary>
        </member>
        <member name="M:Megumin.Utility2.ToStringReflection``1(``0,System.Boolean)">
            <summary>
            通过反射获得属性值字符串,一般用于打印到控制台.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="actualType">默认true通过value取得实际类型,false取得泛型类型,T可能是接口类型</param>
            <returns></returns>
        </member>
        <member name="T:Megumin.UtilTime">
            <summary>
            计时（服务器用）
            </summary>
        </member>
        <member name="P:Megumin.UtilTime.DeltaTime">
            <summary>
            上一个时间间隔长度（毫秒）
            </summary>
        </member>
        <member name="P:Megumin.UtilTime.TotalMilliseconds">
            <summary>
            获取以整毫秒数和毫秒的小数部分表示的当前 System.TimeSpan 结构的值。
            </summary>
        </member>
        <member name="M:Megumin.UtilTime.Update">
            <summary>
            更新时间间隔
            </summary>
            <returns></returns>
        </member>
        <member name="M:Megumin.ObsoleteValueTaskSource`1.EatContinuation(System.Int16)">
            <summary>
            吃掉异步后续，释放关联引用，什么也不会发生。
            </summary>
            <param name="token"></param>
        </member>
        <member name="T:Megumin.TempValueTaskSource`1">
            <summary>
            临时使用的IValueTaskSource，线程安全，但是没有性能优化。当作包装类使用。
            <para/> 不支持executioncontext 和 synchronizationcontext
            <para/> https://devblogs.microsoft.com/pfxteam/executioncontext-vs-synchronizationcontext/
            </summary>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="F:Megumin.TempValueTaskSource`1.resetEvent">
            <summary>
            为了实现挂起时访问<see cref="P:System.Threading.Tasks.ValueTask`1.Result"/>阻塞线程。
            </summary>
        </member>
        <member name="M:Megumin.TempValueTaskSource`1.Reset">
            <summary>
            清理所有状态，准备重用
            </summary>
        </member>
        <member name="M:Megumin.TempValueTaskSource`1.FreeContinuation">
            <summary>
            释放已等待异步后续，释放关联引用，什么也不触发。
            </summary>
        </member>
        <member name="T:Megumin.TempValueTaskSource">
            <inheritdoc/>
        </member>
        <member name="T:Megumin.ForgetValueTaskSource`1">
            <summary>
            舍弃一个异步，永远不能触发
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Megumin.ForgetValueTaskSource`1.ForgetIt">
            <summary>
            返回一个永远不会完成的Task
            </summary>
        </member>
        <member name="P:Megumin.ForgetValueTaskSource.ForgetIt">
            <summary>
            返回一个永远不会完成的Task
            </summary>
        </member>
        <member name="T:Megumin.ValueTaskPool`1">
            <summary>
            没有意义。直接用TaskCompletionSource 就行。
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Megumin.WeakEvent">
            <summary>
            TODO,GC回收不掉，不知道为什么还是有强引用
            </summary>
        </member>
        <member name="T:Megumin.WeakReferenceList`1">
            <summary>
            弱引用集合,用于全局遍历
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Megumin.WeakReferenceList`1.ForEachAutoRemoveNull(System.Action{`0})">
            <summary>
            https://source.dot.net/#System.Private.CoreLib/List.cs,879
            RemoveAll 通过双指针实现,应该不影响效率,
            但是每次使用Action会产生闭包,不一定比feache 和 RemoveAll 效率高
            </summary>
            <param name="action"></param>
        </member>
        <member name="T:Megumin.OnValueGet`1">
            <summary>
            当值被访问时被调用。
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <remarks>
            保持API一致性。<see cref="T:Megumin.OnValueSet`1"/>
            虽然应该是Got，但是为了一致性。
            </remarks>
        </member>
        <member name="T:Megumin.OnValueSet`1">
            <summary>
            当值被赋值后被调用，无论新值是否与旧值相等。
            </summary>
            <typeparam name="T"></typeparam>
            <param name="newValue"></param>
            <param name="oldValue"></param>
            <remarks>
            Set过去式也是Set。
            </remarks>
        </member>
        <member name="T:Megumin.OnValueChanged`1">
            <summary>
            当值发生改变后被调用。
            </summary>
            <typeparam name="T"></typeparam>
            <param name="newValue">新的值</param>
            <param name="oldValue">旧的值</param>
        </member>
        <member name="T:Megumin.OnGet`1">
            <summary>
            当值被访问时被调用。
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <remarks>
            保持API一致性。<see cref="T:Megumin.OnSet`1"/>
            虽然应该是Got，但是为了一致性。
            </remarks>
        </member>
        <member name="T:Megumin.OnSet`1">
            <summary>
            当值被赋值后被调用，无论新值是否与旧值相等。
            </summary>
            <typeparam name="T"></typeparam>
            <param name="newValue"></param>
            <param name="oldValue"></param>
            <remarks>
            Set过去式也是Set。
            </remarks>
        </member>
        <member name="T:Megumin.OnChanged`1">
            <summary>
            当值发生改变后被调用。
            </summary>
            <typeparam name="T"></typeparam>
            <param name="newValue">新的值</param>
            <param name="oldValue">旧的值</param>
        </member>
        <member name="T:Megumin.Axial">
            <summary>
            轴向
            </summary>
        </member>
        <member name="T:Megumin.AxialAigned">
            <summary>
            带符号的轴向
            </summary>
        </member>
        <member name="F:Megumin.AxialAigned.Xn">
            <summary>
            负x
            </summary>
        </member>
        <member name="F:Megumin.AxialAigned.Yn">
            <summary>
            负y
            </summary>
        </member>
        <member name="F:Megumin.AxialAigned.Zn">
            <summary>
            负z
            </summary>
        </member>
        <member name="T:Megumin.LeftOrRight">
            <summary>
            左中右
            </summary>
        </member>
        <member name="T:Megumin.URDL">
            <summary>
            顺时针 上右下左
            </summary>
        </member>
        <member name="T:Megumin.Sudoku">
            <summary>
            九宫格 顺时针布局
            <para> 7 0 1 </para>
            <para> 6 8 2 </para>
            <para> 5 4 3 </para>
            </summary>
        </member>
        <member name="T:Megumin.KeypadSudoku">
            <summary>
            九宫格 小键盘布局
            <para> 7 8 9 </para>
            <para> 4 5 6 </para>
            <para> 1 2 3 </para>
            </summary>
        </member>
        <member name="F:Megumin.KeypadSudoku.NegativeCenter">
            <summary>
            负中心，没什么实际意义，因为 第0位 空着，所以当作填充用。
            </summary>
        </member>
        <member name="T:Megumin.LineMode">
            <summary>
            联机模式/网络可连接状态
            </summary>
            <![CDATA[
            if(CurrentLineMode > LineMode.LAN)
            {
                //当前有公网连接
            }
            ]]>
        </member>
        <member name="F:Megumin.LineMode.Offline">
            <summary>
            离线/无网络连接
            </summary>
        </member>
        <member name="F:Megumin.LineMode.Single">
            <summary>
            单机模式/与本机可连接
            </summary>
        </member>
        <member name="F:Megumin.LineMode.LAN">
            <summary>
            局域网/局域网内可连接
            </summary>
        </member>
        <member name="F:Megumin.LineMode.Online">
            <summary>
            在线/可与公网连接
            </summary>
        </member>
        <member name="T:Megumin.PluginState">
            <summary>
            插件状态
            </summary>
        </member>
        <member name="F:Megumin.PluginState.Null">
            <summary>
            插件为空
            </summary>
        </member>
        <member name="F:Megumin.PluginState.Initing">
            <summary>
            正在初始化
            </summary>
        </member>
        <member name="F:Megumin.PluginState.InitErrorAndStop">
            <summary>
            初始化失败已停止工作
            </summary>
        </member>
        <member name="F:Megumin.PluginState.ReIniting">
            <summary>
            重新初始化
            </summary>
        </member>
        <member name="F:Megumin.PluginState.InitFinish">
            <summary>
            初始化完成
            </summary>
        </member>
        <member name="F:Megumin.PluginState.Open">
            <summary>
            开启
            </summary>
        </member>
        <member name="F:Megumin.PluginState.Close">
            <summary>
            关闭
            </summary>
        </member>
        <member name="F:Megumin.PluginState.Dispose">
            <summary>
            已释放
            </summary>
        </member>
        <member name="T:Megumin.ISamplable">
            <summary>
            可采样的
            </summary>
        </member>
        <member name="T:Megumin.ISamplable`1">
            <summary>
            可采样的
            </summary>
        </member>
        <member name="T:Megumin.IEvaluable">
            <summary>
            可估值的
            </summary>
        </member>
        <member name="M:Megumin.IEvaluable.Evaluate">
            <summary>
            求解
            </summary>
        </member>
        <member name="T:Megumin.ICalculable">
            <summary>
            可计算的/可求值的
            </summary>
        </member>
        <member name="T:Megumin.ICalculable`1">
            <summary>
            可计算的/可求值的
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Megumin.IMessageBox">
            <summary>
            返回值约定[0：取消;1：确定；2：帮助；]
            </summary>
        </member>
        <member name="T:Megumin.IMessageBox.MessageBoxButtons">
            <summary>
            参考 https://docs.microsoft.com/en-us/dotnet/api/system.windows.forms.messageboxbuttons?view=net-5.0
            </summary>
        </member>
        <member name="M:Megumin.IMessageBox.Show(System.Object,System.Object,Megumin.IMessageBox.MessageBoxButtons,System.Object)">
            <summary>
            对话框通用api
            </summary>
            <param name="title"></param>
            <param name="content"></param>
            <param name="buttons"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="T:Megumin.IMultiple`2">
            <summary>
            对象 或者 抽象概念 由多个部分构成。
            <para/> 根据一个或多个值，得到一个结果值。多个部分可能随时添加或者移除
            <para/> 运算规则可能为排序，求和，均值等多种算法，用于不同业务场景。
            <para/> 例如：是否静音由多个业务模块同时控制。最大血量可能由多个装备求和。
            </summary>
        </member>
        <member name="P:Megumin.IMultiple`2.DefaultKey">
            <summary>
            默认值Key
            </summary>
        </member>
        <member name="P:Megumin.IMultiple`2.DefaultValue">
            <summary>
            默认值
            </summary>
            <remarks>有必要存在,有的需求要设定的值可能就是默认值取反</remarks>
        </member>
        <member name="P:Megumin.IMultiple`2.CurrentKey">
            <summary>
            当前值的Key,可能为无效值,看计算方式.
            </summary>
        </member>
        <member name="P:Megumin.IMultiple`2.Current">
            <summary>
            当前值
            </summary>
        </member>
        <member name="M:Megumin.IMultiple`2.Add(`0,`1,System.Boolean)">
            <summary>
            添加一个构成项
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="forceRaiseEvent"></param>
        </member>
        <member name="M:Megumin.IMultiple`2.Remove(`0,`1,System.Boolean)">
            <summary>
            移除一个构成项
            </summary>
            <param name="key"></param>
            <param name="value">因为总是复制粘贴Add,参数个数对不上,这个值没有使用,只是为了对齐参数个数.</param>
            <param name="forceRaiseEvent"></param>
        </member>
        <member name="M:Megumin.IMultiple`2.RemoveAll(System.Boolean)">
            <summary>
            取消除默认值以外的所有构成项
            </summary>
        </member>
        <member name="E:Megumin.IMultiple`2.ValueChanged">
            <summary>
            仅当值发生改变时被调用
            </summary>
        </member>
        <member name="E:Megumin.IMultiple`2.ValueChangedKV">
            <summary>
            仅当值发生改变时被调用
            </summary>
        </member>
        <member name="E:Megumin.IMultiple`2.KeyOrValueChanged">
            <summary>
            当前键值任一发生改变时被调用
            </summary>
        </member>
        <member name="T:Megumin.IMatcher`2">
            <summary>
            匹配器
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="K"></typeparam>
        </member>
        <member name="M:Megumin.IMatcher`2.Match(`0,`1)">
            <summary>
            检测两个对象是否可以匹配
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
            <remarks>匹配是单向的，交换参数位置可能导致结果不同</remarks>
        </member>
        <member name="T:Megumin.IMatchable`1">
            <summary>
            可匹配的
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Megumin.IMatchable`1.Match(`0)">
            <summary>
            目标对象是否与自身匹配
            </summary>
            <param name="target"></param>
            <returns></returns>
            <remarks>匹配是单向的，即使目标与自身匹配，自身不一定与目标匹配</remarks>
        </member>
        <member name="T:Megumin.IPath">
            <summary>
            路径
            </summary>
        </member>
        <member name="T:Megumin.INode">
            <summary>
            节点
            </summary>
        </member>
        <member name="T:Megumin.INode`1">
            <summary>
            
            </summary>
            <typeparam name="V"></typeparam>
        </member>
        <member name="T:Megumin.ISlot">
            <summary>
            插槽
            </summary>
        </member>
        <member name="T:Megumin.ISlot`2">
            <summary>
            插槽
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="T:Megumin.IVisibleable">
            <summary>
            含有可见性的
            </summary>
        </member>
        <member name="T:Megumin.IVisibleLevelable">
            <summary>
            含有可见性等级的
            </summary>
        </member>
        <member name="P:Megumin.IVisibleLevelable.VisibleLevel">
            <summary>
            可见等级
            </summary>
        </member>
        <member name="T:Megumin.IVersionable">
            <summary>
            含有版本的
            </summary>
        </member>
        <member name="P:Megumin.IVersionable.Version">
            <summary>
            当前版本
            </summary>
        </member>
        <member name="T:Megumin.IF1able">
            <summary>
            F1帮助相关
            </summary>
        </member>
        <member name="T:Megumin.IDebugable">
            <summary>
            todo 调试相关
            </summary>
        </member>
        <member name="T:Megumin.ITimeoutOption">
            <summary>
            超时选项。
            </summary>
        </member>
        <member name="P:Megumin.ITimeoutOption.MillisecondsTimeout">
            <summary>
            指定毫秒后超时，-1表示永不超时。
            <seealso cref="M:System.Threading.CancellationTokenSource.CancelAfter(System.Int32)"/>
            </summary>
        </member>
        <member name="T:Megumin.IPipe`1">
            <summary>
            管道队列，用于处理生产者已经产出，消费者还没有就绪的情况
            <para/>也可以通过（bool isEnd,T value）元组，来实现终止信号
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>
            线程同步上下文由Task机制保证，无需额外处理
            SynchronizationContext callbackContext;
            public bool UseSynchronizationContext { get; set; } = true;
            </remarks>
        </member>
        <member name="M:Megumin.IPipe`1.Enqueue(`0)">
            <summary>
            入队，但是不触发异步回调
            </summary>
            <param name="item"></param>
            <remarks>
            用例：有时候生产者同时生产多个值，不想逐个触发异步回调，就需要多个值都Enqueue，然后一次Flush。
            </remarks>
        </member>
        <member name="M:Megumin.IPipe`1.Flush">
            <summary>
            尝试触发异步回调
            </summary>
        </member>
        <member name="M:Megumin.IPipe`1.FlushAsync">
            <summary>
            异步尝试触发异步回调
            </summary>
        </member>
        <member name="M:Megumin.IPipe`1.ReadAsync">
            <summary>
            当队列中有元素时返回。
            </summary>
            <returns></returns>
        </member>
        <member name="M:Megumin.IPipe`1.ReadValueTaskAsync">
            <summary>
            当队列中有元素时返回。
            </summary>
            <returns></returns>
        </member>
        <member name="M:Megumin.IPipe`1.Write(`0)">
            <summary>
            写入，同时触发ReadAsync异步延续
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Megumin.IPipe`1.WriteAsync(`0)">
            <summary>
            写入，同时异步触发ReadAsync异步延续
            </summary>
            <param name="item"></param>
        </member>
        <member name="T:Megumin.IValuePipe`1">
            <summary>
            <inheritdoc cref="T:Megumin.IPipe`1"/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Megumin.IValuePipe`1.ReadAsync">
            <summary>
            当队列中有元素时返回。
            </summary>
            <returns></returns>
        </member>
        <member name="T:Megumin.ITimeControlable">
            <summary>
            时间控制
            </summary>
        </member>
        <member name="M:Megumin.ITimeControlable.Pause(System.Object)">
            <summary>
            暂停
            </summary>
            <param name="option"></param>
            <returns></returns>
        </member>
        <member name="M:Megumin.ITimeControlable.Resume(System.Object)">
            <summary>
            继续
            </summary>
            <param name="option"></param>
            <returns></returns>
        </member>
        <member name="M:Megumin.ICDTicker`1.Check(`0,`0)">
            <summary>
            检查计时器当前时刻与记录时刻比较，是不是大于perSpan, 
            </summary>
            <param name="stamp">记录时刻</param>
            <param name="perSpan">间隔时长</param>
            <returns>
            完成间隔次数,最后检查点，距离下次完成时长
            </returns>
        </member>
        <member name="T:Megumin.IUseable">
            <summary>
            可使用的.  
            <para/>包括冷却型的和充能型的,物品堆叠型的
            <para>支持充能点数</para>
            </summary>
            <remarks>
            设计目的: 对模型层一个抽象,View层显示图标状态使用这个接口访问模型层数据信息.
            是否可用 比 CD相关功能范围更大
            比如猎空黑影技能
            </remarks>
        </member>
        <member name="P:Megumin.IUseable.CanUse">
            <summary>
            当前是不是可用，至少含有1点。
            </summary>
        </member>
        <member name="P:Megumin.IUseable.IsUsing">
            <summary>
            正在使用中
            </summary>
            <remarks>
            比如黑影的隐身,猎空的闪回,使用是一个持续过程
            </remarks>
        </member>
        <member name="M:Megumin.IUseable.TryUse(System.Int32)">
            <summary>
            使用掉一个可用点数
            </summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="P:Megumin.IUseable.MaxCanUseCount">
            <summary>
            最大可用点数
            </summary>
        </member>
        <member name="P:Megumin.IUseable.ResidualCanUseCount">
            <summary>
            当前剩余可用点数
            </summary>
        </member>
        <member name="M:Megumin.IUseable.ForceAddResidualCanUseCount(System.Int32)">
            <summary>
            强制增加当前可用点数
            </summary>
            <param name="count"></param>
        </member>
        <member name="T:Megumin.IUseable`1">
            <inheritdoc/>
        </member>
        <member name="P:Megumin.IUseable`1.NextCanUse">
            <summary>
            无论当前可用点数是多少，距离下一次冷却完成的时长，返回值总是[0-PerSpan]
            </summary>
            <remarks>想象一下最大可用5，当前可用2，然后倒计时扇形显示的是到下个可用点的时间，而不是到最大可用的时间</remarks>
        </member>
        <member name="P:Megumin.IUseable`1.PerSpan">
            <summary>
            每完成一个冷却点数所需的时间
            </summary>
        </member>
        <member name="T:Megumin.IXYZ`1">
            <summary>
            
            </summary>
            <remarks>不要重写比较方法</remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:StringExtension_E68DD56066C94F2286AF4BD18126A406">
            <summary>
            string扩展
            </summary>
        </member>
        <member name="M:StringExtension_E68DD56066C94F2286AF4BD18126A406.Split(System.String,System.Int32,System.Boolean)">
            <summary>
            按指定长度分割字符串
            </summary>
            <param name="s"></param>
            <param name="perLength">每段长度</param>
            <param name="allowLastOneShortCount">是够允许最后一段长度小于每段长度，
            如果为false，不足的末尾将被舍弃。默认为false。</param>
            <returns></returns>
        </member>
        <member name="M:StringExtension_E68DD56066C94F2286AF4BD18126A406.ToInt(System.String)">
            <summary>
            使用int.Parse转换一个字符串
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:StringExtension_E68DD56066C94F2286AF4BD18126A406.ToEnum``1(System.String)">
            <summary>
            将一个字符串转换成枚举
            </summary>
            <typeparam name="T">提供一个枚举类型</typeparam>
            <param name="value"></param>
            <returns>返回对应的枚举值</returns>
            <exception cref="T:System.ArgumentException">所给泛型不是枚举</exception>
        </member>
        <member name="M:StringExtension_E68DD56066C94F2286AF4BD18126A406.ToBool(System.String)">
            <summary>
            将string转换成bool。
            <para>当值为"true""TRUE""True"之一时返回true，否则返回false。</para>
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:StringExtension_E68DD56066C94F2286AF4BD18126A406.IsDigit(System.Char,System.Int32,System.Int32@)">
            <summary>
            https://source.dot.net/#System.Private.CoreLib/ParseNumbers.cs,634
            </summary>
            <param name="c"></param>
            <param name="radix"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:StringExtension_E68DD56066C94F2286AF4BD18126A406.CompareAaBbCc(System.String,System.String)">
            <summary>
            按照AaBbCc排序比较
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:StructExtension_28FDB7156FD24F39B5EA39D95892E328">
            <summary>
            值扩展
            </summary>
        </member>
        <member name="M:StructExtension_28FDB7156FD24F39B5EA39D95892E328.Clamp``1(``0@,``0@,``0@)">
            <summary>
            将值限定在指定范围内
            </summary>
            <typeparam name="T"></typeparam>
            <param name="cur"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:StructExtension_28FDB7156FD24F39B5EA39D95892E328.GetClamp``1(``0,``0@,``0@)">
            <summary>
            返回限定在指定范围内的值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="cur"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:StructExtension_28FDB7156FD24F39B5EA39D95892E328.ClampIn``1(``0@,``0@,``0@)">
            <summary>
            将值限定在指定范围内,不知道两个边界谁大谁小，消息比<see cref="M:StructExtension_28FDB7156FD24F39B5EA39D95892E328.Clamp``1(``0@,``0@,``0@)"/>低一些。
            </summary>
            <typeparam name="T"></typeparam>
            <param name="cur"></param>
            <param name="value1"></param>
            <param name="value2"></param>
        </member>
        <member name="M:StructExtension_28FDB7156FD24F39B5EA39D95892E328.SnapCeil(System.Int32@,System.Double)">
            <summary>
            
            </summary>
            <param name="orignal"></param>
            <param name="multiple">倍数</param>
        </member>
        <member name="M:StructExtension_28FDB7156FD24F39B5EA39D95892E328.SnapRound(System.Int32@,System.Double)">
            <summary>
            就近舍入  四舍六入五近偶
            </summary>
            <param name="orignal"></param>
            <param name="multiple"></param>
        </member>
        <member name="M:StructExtension_28FDB7156FD24F39B5EA39D95892E328.SnapFloor(System.Int32@,System.Double)">
            <summary>
            
            </summary>
            <param name="orignal"></param>
            <param name="multiple">倍数</param>
        </member>
        <member name="M:StructExtension_28FDB7156FD24F39B5EA39D95892E328.SnapCeil(System.Double@,System.Double)">
            <summary>
            
            </summary>
            <param name="orignal"></param>
            <param name="multiple">倍数</param>
        </member>
        <member name="M:StructExtension_28FDB7156FD24F39B5EA39D95892E328.SnapRound(System.Double@,System.Double)">
            <summary>
            就近舍入  四舍六入五近偶
            </summary>
            <param name="orignal"></param>
            <param name="multiple"></param>
        </member>
        <member name="M:StructExtension_28FDB7156FD24F39B5EA39D95892E328.SnapFloor(System.Double@,System.Double)">
            <summary>
            
            </summary>
            <param name="orignal"></param>
            <param name="multiple">倍数</param>
        </member>
        <member name="M:TypeExtension_7AE0B2E4B4124A53AE87CE8D95431431.FirstAttribute``1(System.Type)">
            <summary>
            尝试取得第一个指定属性
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TypeExtension_7AE0B2E4B4124A53AE87CE8D95431431.IsSubclassOfRawGeneric(System.Type,System.Type)">
            <summary>
            https://stackoverflow.com/a/457708/15201132
            </summary>
            <param name="generic"></param>
            <param name="toCheck"></param>
            <returns></returns>
        </member>
        <member name="M:TypeExtension_7AE0B2E4B4124A53AE87CE8D95431431.IsSubClassOfGeneric(System.Type,System.Type)">
            <summary>
            https://stackoverflow.com/a/18828085/15201132
            </summary>
            <param name="child"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:TypeExtension_7AE0B2E4B4124A53AE87CE8D95431431.GetInnerType(System.Type,System.Boolean)">
            <summary>
            取得实际类型，泛型中的填充类型
            </summary>
            <param name="fieldType"></param>
            <param name="useGenericArgumentsTypeInsteadCollectionType"></param>
            <returns></returns>
        </member>
    </members>
</doc>
